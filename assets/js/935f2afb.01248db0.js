"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Learn","collapsed":false,"items":[{"type":"link","label":"Getting started","href":"/getting-started","docId":"getting-started"},{"type":"link","label":"Core Concepts","href":"/core-concepts","docId":"core-concepts"},{"type":"link","label":"Installation","href":"/installation","docId":"installation"},{"type":"link","label":"Design choices","href":"/design-choices","docId":"design-choices"}],"collapsible":true},{"type":"category","label":"API","collapsed":false,"items":[{"type":"link","label":"Option","href":"/option","docId":"option"},{"type":"link","label":"Result","href":"/result","docId":"result"},{"type":"category","label":"Async Data","collapsed":false,"items":[{"type":"link","label":"AsyncData","href":"/async-data","docId":"async-data"},{"type":"link","label":"AsyncData<Result> helpers","href":"/async-data-result","docId":"async-data-result"}],"collapsible":true},{"type":"category","label":"Future","collapsed":false,"items":[{"type":"link","label":"Future<Value>","href":"/future","docId":"future"},{"type":"link","label":"Future<Result> helpers","href":"/future-result","docId":"future-result"}],"collapsible":true},{"type":"link","label":"Deferred","href":"/deferred","docId":"deferred"},{"type":"link","label":"Array","href":"/array","docId":"array"},{"type":"link","label":"Dict","href":"/dict","docId":"dict"},{"type":"link","label":"Lazy","href":"/lazy","docId":"lazy"},{"type":"link","label":"Serializer","href":"/serializer","docId":"serializer"}],"collapsible":true},{"type":"category","label":"Examples","collapsed":false,"items":[{"type":"link","label":"React Request","href":"/react-request","docId":"react-request"},{"type":"link","label":"Form Validation","href":"/form-validation","docId":"form-validation"},{"type":"link","label":"Nested optional values","href":"/nested-optional-values","docId":"nested-optional-values"},{"type":"link","label":"Cancellable Request","href":"/cancellable-request","docId":"cancellable-request"},{"type":"link","label":"Retry","href":"/retry","docId":"retry"},{"type":"link","label":"Concurrency","href":"/concurrency","docId":"concurrency"}],"collapsible":true},{"type":"link","label":"Inspirations","href":"/inspirations","docId":"inspirations"}]},"docs":{"array":{"id":"array","title":"Array","description":"Array.filterMap(array, func)","sidebar":"docs"},"async-data":{"id":"async-data","title":"AsyncData<Value>","description":"The AsyncData type enables representing asynchronous flows (e.g. requests). The type represents the state as a discriminating union, avoiding manual management for loading flows.","sidebar":"docs"},"async-data-result":{"id":"async-data-result","title":"AsyncData<Result<Ok, Error>>","description":"A AsyncData can contain a Result (e.g. to represent an asynchronous value that can fail). We provide some utility functions to deal with that case without having to unwrap the AsyncData result.","sidebar":"docs"},"cancellable-request":{"id":"cancellable-request","title":"Cancellable Request","description":"When using the naive fetch, cancelling a request can be inelegant:","sidebar":"docs"},"concurrency":{"id":"concurrency","title":"Concurrency","description":"While you have a simple Future.all to run all futures in parallel (like Promise.all does), you might want to limit the concurrency at which you execute operations.","sidebar":"docs"},"core-concepts":{"id":"core-concepts","title":"Core Concepts","description":"The Boxed approach takes root in typed functional paradigms. We know that these concepts can be overwhelming, especially with their jargon and mathematical concepts, and therefore want to make them more accessible.","sidebar":"docs"},"deferred":{"id":"deferred","title":"Deferred<Value>","description":"Deferred.make()","sidebar":"docs"},"design-choices":{"id":"design-choices","title":"Design choices","description":"Chaining API","sidebar":"docs"},"dict":{"id":"dict","title":"Dict","description":"Dict.entries(dict)","sidebar":"docs"},"form-validation":{"id":"form-validation","title":"Form Validation","description":"A common need in applications is to validate user-input before sending it to the server.","sidebar":"docs"},"future":{"id":"future","title":"Future<Value>","description":"The Future is a replacement for Promise.","sidebar":"docs"},"future-result":{"id":"future-result","title":"Future<Result<Ok, Error>>","description":"A Future can contain a Result (e.g. to represent an asynchronous value that can fail). We provide some utility functions to deal with that case without having to unwrap the Future result.","sidebar":"docs"},"getting-started":{"id":"getting-started","title":"Getting started","description":"Boxed provides essential building-blocks to solve common issues you can run into in your application or library development.","sidebar":"docs"},"inspirations":{"id":"inspirations","title":"Inspirations","description":"- ReScript\'s Belt Stdlib","sidebar":"docs"},"installation":{"id":"installation","title":"Installation","description":"Prerequisites","sidebar":"docs"},"lazy":{"id":"lazy","title":"Lazy","description":"Lazy(f)","sidebar":"docs"},"nested-optional-values":{"id":"nested-optional-values","title":"Nested optional values","description":"Managing optionality with undefined and null can lead to tedious code, especially when dealing with default values.","sidebar":"docs"},"option":{"id":"option","title":"Option<Value>","description":"The Option type can be used as a replacement for null and undefined when manipulating optional data. Contrary to null and undefined, an option is kind of like a box, that contains a value or not.","sidebar":"docs"},"react-request":{"id":"react-request","title":"React Request","description":"The AsyncData type removes the need for manual request modeling.","sidebar":"docs"},"result":{"id":"result","title":"Result<Ok, Error>","description":"The Result can replace exception flows.","sidebar":"docs"},"retry":{"id":"retry","title":"Retry","description":"When some operations can fail, you might want to implement a retry logic.","sidebar":"docs"},"serializer":{"id":"serializer","title":"Serializer","description":"The serializer enables you to serialize some Boxed values (e.g. to store in LocalStorage, or to hydrate data from SSR).","sidebar":"docs"}}}')}}]);